// Generated by CoffeeScript 2.5.1
(function() {
  window.HTMLProcessor = class HTMLProcessor {
    constructor(sendEvent, setDocumentElementInnerHTML, getIDFn) {
      this.processHTML = this.processHTML.bind(this);
      this.processTitle = this.processTitle.bind(this);
      // Returns HTML for displaying a "theserver.com/image.jpg" url page
      this.processImageAsHTML = this.processImageAsHTML.bind(this);
      this.processImages = this.processImages.bind(this);
      this.processScripts = this.processScripts.bind(this);
      this.processStyleSheets = this.processStyleSheets.bind(this);
      // Links are handled somewhat differently in that the contents cannot be injected on page load.
      //   Instead, here we set up an onclick function for each anchor tag, and make the href a no-op (by
      //   placing return false in the onclick function.)
      //   External anchor tags are handled by having them open in a new window ("_blank"). Another option
      //   here would be to have them open in the top window (ie, the main actual window rather than the frame)
      //   by using "target='_top'.
      // TODO it might be worth making this more robust with identifying internal files.
      this.processLinks = this.processLinks.bind(this);
      // Triggers an event on the top (actual) window, passing in href as the parameter.
      //  The return false is important so that the href portion of the link is ignored.
      this.triggerOnParentString = this.triggerOnParentString.bind(this);
      this.processElementsWithAttribute = this.processElementsWithAttribute.bind(this);
      this.isInternalFile = this.isInternalFile.bind(this);
      // Note that requestFile is also called externally (ie, by the global function that
      //   handles a href tags being clicked.)
      this.requestFile = this.requestFile.bind(this);
      //  For filenames, removes any trailing slash if it exists.
      this.removeTrailingSlash = this.removeTrailingSlash.bind(this);
      this.receiveFile = this.receiveFile.bind(this);
      this.handleFileForElem = this.handleFileForElem.bind(this);
      this.handleSupportingFile = this.handleSupportingFile.bind(this);
      this.checkForProcessCompletion = this.checkForProcessCompletion.bind(this);
      this.sendEvent = sendEvent;
      this.setDocumentElementInnerHTML = setDocumentElementInnerHTML;
      this.getIDFn = getIDFn;
      this.requestedFilenamesToElement = {};
      this.container = null;
      this.completionCallback = null;
    }

    processHTML(html, completionCallback) {
      var container;
      this.completionCallback = completionCallback;
      this.scriptMapping = {};
      container = document.createElement("html");
      container.innerHTML = html.replace(/<\/?html>/g, "");
      this.container = $(container);
      this.processTitle();
      this.processImages();
      this.processScripts();
      this.processStyleSheets();
      this.processLinks();
      // Ensure that this is called just in case there is nothing to be processed
      return this.checkForProcessCompletion();
    }

    processTitle() {
      var elements;
      elements = this.container.find("title");
      return elements.each((index, el) => {
        var $el;
        $el = $(el);
        return document.title = $el.text();
      });
    }

    processImageAsHTML(html, completionCallback) {
      var container, img;
      this.completionCallback = completionCallback;
      container = document.createElement("html");
      this.container = $(container);
      // Set the style so that the image is centered
      // TODO: possibly soup this up with zooming in and out of images (just requires a script
      //  listening to the window size and resizing if needed, plus a zoom-in zoom-out cursor)
      img = "<img style='text-align:center; position:absolute; margin:auto; top:0;right:0;bottom:0;left:0;' ";
      img += " src='" + html + "' />";
      this.container.append($(img));
      return this.completionCallback(this.container[0].outerHTML);
    }

    processImages() {
      return this.processElementsWithAttribute(this.container.find("img[src]"), "src", "image");
    }

    processScripts() {
      return this.processElementsWithAttribute(this.container.find("script[src]"), "src", "script");
    }

    processStyleSheets() {
      var elements;
      elements = this.container.find("link[rel=\"stylesheet\"]");
      elements.add(this.container.find("link[rel=\'stylesheet\']")); // For Chrome, likely. Not needed for Firefox
      return this.processElementsWithAttribute(elements, "href", "stylesheet");
    }

    processLinks() {
      var elements;
      elements = this.container.find("a[href]");
      return elements.each((index, el) => {
        var $el, href;
        $el = $(el);
        // Don't change the href so that the hover behavior is correct --
        // instead, it will be ignored because onclick returns false.
        href = $el.attr("href");
        // Ignore local links
        if (href[0] === "#") {

        } else if (this.isInternalFile(href)) {
          return $el.attr("onclick", this.triggerOnParentString("relativeLinkClicked", href));
        } else {
          return $el.attr("target", "_blank");
        }
      });
    }

    triggerOnParentString(eventName, href) {
      return "javascript:top.$(top.document).trigger('" + eventName + "', ['" + href + "']);return false;";
    }

    processElementsWithAttribute(elements, attrSelector, type) {
      return elements.each((index, el) => {
        var $el, filename;
        $el = $(el);
        filename = $el.attr(attrSelector);
        if (this.isInternalFile(filename)) {
          if (filename in this.requestedFilenamesToElement) {
            return this.requestedFilenamesToElement[filename].push($el);
          } else {
            // Do not need to request this file because a request is already pending for it.
            this.requestedFilenamesToElement[filename] = [$el];
            return this.requestFile(filename, type);
          }
        }
      });
    }

    isInternalFile(filename) {
      // Hack -- basically, an internal file can't start with "#" and shouldn't match http/https.
      if (filename[0] !== "#" && filename.match(/(?:https?:\/\/)|(?:data:)/) === null) {
        return true;
      }
      return false;
    }

    requestFile(filename, type) {
      var data;
      data = {
        "filename": filename,
        "socketId": this.getIDFn(),
        "type": type
      };
      return this.sendEvent("requestFile", data);
    }

    removeTrailingSlash(str) {
      if (!str || str === "") {
        return str;
      }
      if (str.charAt(str.length - 1) === "/") {
        return str.substr(0, str.length - 1);
      }
      return str;
    }

    receiveFile(data) {
      var fileContents, fileType, filename, type;
      filename = this.removeTrailingSlash(data.filename);
      fileContents = data.fileContents;
      type = data.type; // Same as what we passed along in request file.
      fileType = data.fileType; // IMG, JS, CSS, HTML, etc.
      
      // Handles a file type being sent in that refreshes the entire page.
      // Change the entire frame's contents to be the received html file.
      // Setting the document inner HTML calls the webRTC method passed in, which initiates
      //   another round of setting up the HTML for the frame (with processing).
      if (type === "alink" || type === "backbutton" || type === "initialLoad" || type === "submit") {
        return this.setDocumentElementInnerHTML({
          "fileContents": data.fileContents,
          "filename": filename,
          "fileType": fileType
        }, type);
      } else {
        return this.handleSupportingFile(data, filename, fileContents, type, fileType);
      }
    }

    handleFileForElem($element, data, filename, fileContents) {
      if (!$element) {
        console.error("element is null: " + filename);
        return;
      }
      if ($element.attr("src") && $element[0].tagName === "IMG") {
        return $element.attr("src", fileContents);
      } else if ($element.attr("src") && $element[0].tagName === "SCRIPT") {
        $element.removeAttr("src"); // TODO remove later?
        $element.attr("todo-replace", "replace");
        this.scriptMapping[data.filename] = fileContents;
        // NOTE: this is dangerous b/c we might get encoded if the filename has bad characters in it
        //   (which I think is plausible), and then we're screwed when we try to find the non-encoded file name
        //   contents using the encoded file name we pull out when we execute the script. It would be safest to include a
        //   unique ID with each file (perhaps imparted by the client-server filestore) that we can use instead.
        //   Basically any unique ID here is fine.
        return $element.append(data.filename);
      } else if ($element[0].tagName === "LINK") {
        return $element.replaceWith("<style>" + fileContents + "</style>");
      } else {
        console.log("unknown element type, could not be processed:");
        return console.log($element);
      }
    }

    handleSupportingFile(data, filename, fileContents, type, fileType) {
      var $element, elems, i, len;
      elems = this.requestedFilenamesToElement[filename];
      if (!elems) {
        console.error("received file not in request list: " + filename);
        return;
      }
      for (i = 0, len = elems.length; i < len; i++) {
        $element = elems[i];
        this.handleFileForElem($element, data, filename, fileContents);
      }
      delete this.requestedFilenamesToElement[filename];
      return this.checkForProcessCompletion();
    }

    checkForProcessCompletion() {
      if (Object.keys(this.requestedFilenamesToElement).length === 0 && this.completionCallback) {
        return this.completionCallback(this.container[0].outerHTML, this.scriptMapping);
      }
    }

  };

}).call(this);
