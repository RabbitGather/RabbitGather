// Generated by CoffeeScript 2.5.1
(function() {
  window.ClientBrowser = class ClientBrowser {
    constructor(documentElement) {
      var startPage;
      // Returns the client-server's own data channel id.
      this.getID = this.getID.bind(this);
      // Finds the socket ID of the desired server through the url.
      this.parseUrl = this.parseUrl.bind(this);
      this.sendEvent = this.sendEvent.bind(this);
      this.channelOnMessage = this.channelOnMessage.bind(this);
      this.setUpReceiveEventCallbacks = this.setUpReceiveEventCallbacks.bind(this);
      // Responds to receiving a file over the data channel, dispatching the file to the
      //   appropriate handler. Ajax files go to the ajax handler, others go to html processor.
      this.receiveFileDispatch = this.receiveFileDispatch.bind(this);
      this.getFullPath = this.getFullPath.bind(this);
      this.setDocumentElementInnerHTML = this.setDocumentElementInnerHTML.bind(this);
      // Note: There will sadly be problems if a script uses $.ajax before this code is executed.
      //  The only way to get around this I think would be to explicitly identify when jQuery is being
      //  loaded in, and set the ajax function then. Might be worth a look in the future -- for now, this works.
      this.overrideAjaxForClient = this.overrideAjaxForClient.bind(this);
      this.overrideFormsForClient = this.overrideFormsForClient.bind(this);
      
      // Responds to a form being submitted that needs to hit the path, possibly with
      //  form input attributes. Parses out the input attributes and dispatches a request
      //  with the form.
      this.handleFormSubmit = this.handleFormSubmit.bind(this);
      // Needed since innerHTML does not run scripts.
      // Inspired by:
      // http://stackoverflow.com/questions/2592092/executing-script-elements-inserted-with-innerhtml
      this.executeScriptsCallback = this.executeScriptsCallback.bind(this);
      this.documentElement = documentElement;
      // Looks at the URL, which must be of the form
      // [host]/connect/[serverSocketId]/[optionalStartPage]
      // desired server is used both as a socket id for joining up via webRTC,
      // as well as in the url path
      [this.desiredServer, startPage] = this.parseUrl(window.location);
      this.pathRoot = "/connect/" + this.desiredServer;
      this.eventTransmitter = new EventTransmitter();
      this.dataChannel = new ClientBrowserDataChannel(this.channelOnMessage, this.desiredServer);
      this.htmlProcessor = new HTMLProcessor(this.sendEvent, this.setDocumentElementInnerHTML, this.getID);
      this.ajaxClient = new AjaxClient(this.sendEvent, this.getID);
      this.setUpReceiveEventCallbacks(startPage);
      window.onpopstate = (evt) => {
        var filename;
        // Chrome calls onpopstate on initial load, in which case evt has no state
        if (evt.state) {
          filename = evt.state.path;
          return this.htmlProcessor.requestFile(filename, "backbutton");
        }
      };
    }

    getID() {
      return this.dataChannel.id;
    }

    parseUrl(locationObj) {
      var pathname, queryStr, result, serverId, slashIndex, startPage, suffix;
      pathname = locationObj.pathname;
      queryStr = locationObj.search;
      if (pathname.indexOf("connect") === -1) {
        console.error("Error: pathname does not contain 'connect'");
      }
      // Get everything after "connect/"
      suffix = pathname.substr("/connect/".length);
      slashIndex = suffix.indexOf("/");
      startPage = null; // Default start page, none specified
      if (slashIndex !== -1) { // Strip out everything after the id if needed
        serverId = suffix.substr(0, slashIndex);
        // i.e., if there are characters following the slash
        if (slashIndex !== (suffix.length - 1)) {
          startPage = suffix.substr(suffix.indexOf("/") + 1);
        }
      } else {
        serverId = suffix;
      }
      result = startPage;
      if (queryStr) {
        result += queryStr;
      }
      result = startPage + queryStr;
      if (!result || result === "null") {
        result = "";
      }
      return [serverId, result];
    }

    sendEvent(eventName, data) {
      return this.eventTransmitter.sendEvent(this.dataChannel, eventName, data);
    }

    channelOnMessage(message) {
      return this.eventTransmitter.receiveEvent(message);
    }

    setUpReceiveEventCallbacks(startPage) {
      this.eventTransmitter.addEventCallback("initialLoad", (data) => {
        if (startPage) { // Ignore the initial file and request the start page
          startPage = this.htmlProcessor.removeTrailingSlash(startPage);
          // Same behavior as if user just clicked on the link
          return this.htmlProcessor.requestFile(startPage, "initialLoad"); // Load in the default start page.
        } else {
          return this.setDocumentElementInnerHTML(data, "initialLoadDefault");
        }
      });
      return this.eventTransmitter.addEventCallback("receiveFile", this.receiveFileDispatch);
    }

    receiveFileDispatch(data) {
      if (data.type === "ajax") {
        return this.ajaxClient.receiveAjax(data);
      } else {
        return this.htmlProcessor.receiveFile(data);
      }
    }

    getFullPath(path) {
      var fullPath;
      fullPath = this.pathRoot;
      if (path[0] !== "/") {
        fullPath += "/";
      }
      return fullPath + path;
    }

    setDocumentElementInnerHTML(data, optionalInfo) {
      var fullPath, html, path;
      html = data.fileContents;
      path = this.htmlProcessor.removeTrailingSlash(data.filename);
      if (optionalInfo !== "backbutton") { // still do it for initialLoadDefault
        fullPath = this.getFullPath(path);
        window.history.pushState({
          "path": path
        }, fullPath, fullPath);
      }
      // console.log "pushed state: " + path
      // console.log window.history.state
      this.documentElement.innerHTML = "";
      if (data.fileType === "IMG") {
        // Serve up a single image
        return this.htmlProcessor.processImageAsHTML(html, (processedHTML) => {
          return this.documentElement.innerHTML = processedHTML;
        });
      } else {
        return this.htmlProcessor.processHTML(html, (processedHTML, scriptMapping) => {
          this.documentElement.innerHTML = processedHTML;
          this.executeScriptsCallback(scriptMapping);
          this.overrideAjaxForClient();
          return this.overrideFormsForClient();
        });
      }
    }

    overrideAjaxForClient() {
      if ((document.getElementById("container").contentWindow.window.jQuery)) {
        return document.getElementById("container").contentWindow.window.jQuery.ajax = function(url, options) {
          return window.clientBrowser.ajaxClient.requestAjax(url, options, options.success, options.error);
        };
      }
    }

    overrideFormsForClient() {
      var forms;
      forms = $(document.getElementById("container").contentWindow.document.forms);
      return forms.submit((evt) => {
        var form, path;
        form = $(evt.target);
        path = form.attr("action");
        if (!path) { // Don't modify the form if there's no path.
          return true; // continue normal form execution
        }
        evt.preventDefault();
        this.handleFormSubmit(form, path);
        return false; // Stop the form from actually redirecting.
      });
    }

    handleFormSubmit(form, path) {
      var data, i, input, len, properties, ref;
      properties = {};
      ref = form.find(":input");
      for (i = 0, len = ref.length; i < len; i++) {
        input = ref[i];
        input = $(input);
        if ($(input).attr("name")) {
          properties[$(input).attr("name")] = input.val();
        }
      }
      data = {
        "filename": path, // Path is more accurate than filename, but use filename for consistency.
        "socketId": this.getID(),
        "options": {
          "data": properties
        },
        "type": "submit"
      };
      return this.sendEvent("requestFile", data);
    }

    executeScriptsCallback(scriptMapping) {
      var filename, i, len, newScriptEl, oldScriptEl, results, scriptElements;
      scriptElements = this.documentElement.getElementsByTagName("script");
      results = [];
      for (i = 0, len = scriptElements.length; i < len; i++) {
        oldScriptEl = scriptElements[i];
        newScriptEl = document.createElement("script");
        newScriptEl.type = "text/javascript";
        if ($(oldScriptEl).attr("todo-replace") === "replace") {
          // This is where the text we read out of oldScriptEl may have weird encodings (ie, &amp for &, etc)
          // The weird encodings will break things (ie, if we tried to just put the script contents in directly)
          // So we're going through the middle step of putting in the filename as an identifier instead.
          // If the filename has weird encodings, though, all hell breaks loose since scriptMapping breaks.
          filename = oldScriptEl.text || oldScriptEl.textContent || oldScriptEl.innerHTML || "";
          if (!scriptMapping[filename]) {
            console.error("Error: " + filename + "was not found in the script mapping. Script will not exist. The script name has bad encoding.");
          }
          newScriptEl.text = scriptMapping[filename];
        } else if (!$(oldScriptEl).attr("src")) { // Inline script
          newScriptEl.text = oldScriptEl.text || oldScriptEl.textContent || oldScriptEl.innerHTML || ""; // External
        } else {
          $(newScriptEl).attr("src", $(oldScriptEl).attr("src"));
        }
        oldScriptEl.parentNode.insertBefore(newScriptEl, oldScriptEl);
        results.push(oldScriptEl.parentNode.removeChild(oldScriptEl));
      }
      return results;
    }

  };

}).call(this);
