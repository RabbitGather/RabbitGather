// Generated by CoffeeScript 2.5.1
(function() {
  `Defines the Route model for handing dynamic paths and
defined path parameters.

There is verification on the UI-end that only valid Routes are initialized.
Specifically:
  - name should be a valid Javascript function name (nonempty, no invalid characters, no spaces, etc)
  - routePath should be a valid path (tokens separated by / without invalid characters in the tokens.
      some of the tokens can be of the form <token> but there shouldn't be any other angle-brackets
      except at the start and end.)
  - reserved words: database, static_file, params  (inspect getExecutableFunction for most up-to-date)`;
  var ref,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  ref = window.Route = (function() {
    class Route extends Backbone.RelationalModel {
      constructor() {
        super(...arguments);
        // Creates the text of a function that can be eval'd to obtain a renderable result.
        // Passes in the param names in order, and a final parameter called "params" containing
        //  the url-parameters (ie, get parameters foo and bar for "page?foo=f&bar=b")
        this.getExecutableFunction = this.getExecutableFunction.bind(this);
        this.getPrettyCurrentDate = this.getPrettyCurrentDate.bind(this);
        // Parses the route path into a list of ordered parameters.
        // Example: "/<first>/foo/<second>/bar/<third>"  -> ["first", "second", "third"]
        this.setParsedPath = this.setParsedPath.bind(this);
        // Remove hash or param list from final path part if needed
        // foo?query=hi&another=hello#somehash is converted to foo
        this.sanitizePathPart = this.sanitizePathPart.bind(this);
        this.validate = this.validate.bind(this);
      }

      initialize() {
        this.setParsedPath();
        // Silly hack here: neutral messages must start with "Note: " to have the right color.
        this.set("errorMessage", "Note: Path has not yet been executed.");
        // console.log "Parsed route: " + @get("routePath") + " " + @pathRegex + " " + @paramNames
        return this.on("change:routePath", this.setParsedPath);
      }

      getExecutableFunction(urlParams, dynamicParams, staticFileFcn, userDatabase, clientSession) {
        var fcn, paramNames, text;
        boundMethodCheck(this, ref);
        text = "(function (";
        paramNames = this.get("paramNames");
        if (paramNames && paramNames.length > 0) {
          text += paramNames.join(", ") + ", ";
        }
        text += "params" + ") {\n";
        text += this.get("routeCode") + "\n })";
        // Now invoke the function with the appropriate parameters
        text += "(";
        if (dynamicParams && dynamicParams.length > 0) {
          dynamicParams = _.map(dynamicParams, function(param) {
            return '"' + param + '"'; // Place all the parameter names in quotes, as they are strings.
          });
          text += dynamicParams.join(",") + ", "; // Pass in the dynamic url-path parameters
        }
        text += JSON.stringify(urlParams) + ")"; // Pass in the get-url parameters
        fcn = () => {
          var cryptoRandom, database, error, evaluation, hash, render_template, result, session, static_file;
          database = userDatabase;
          static_file = staticFileFcn;
          session = clientSession;
          hash = function(value) {
            return "" + CryptoJS.SHA256(value); // Cryptographically secure hash function
          };
          cryptoRandom = function(value) {
            return CryptoJS.lib.WordArray.random(value) + ""; // When called on a number, returns that number of random bytes in hex
          };
          render_template = (filename, context) => {
            var template;
            template = static_file(filename, context);
            if (!template || template.length === 0) {
              throw "Template '" + filename + "' does not exist";
            }
            return window.UserTemplateRenderer.renderTemplate(template, context);
          };
          result = "";
          try {
            evaluation = eval(text);
            if (evaluation) { // Result should stay "" for functions that complete but don't return anything.
              result = evaluation;
            }
          } catch (error1) {
            error = error1;
            console.error("Eval error: " + error);
            error = "Error: evaluation error on function execution: " + error;
            this.set("errorMessage", error);
            return {
              "error": error
            };
          }
          // Silly hack here: success messages must start with "Success: " to have the right color.
          this.set("errorMessage", "Success: Last execution at " + this.getPrettyCurrentDate() + " was successful!"); // reset the error message to null after successful evaluation.
          return {
            "result": result
          };
        };
        return fcn;
      }

      getPrettyCurrentDate() {
        var date, minutes, now, time;
        boundMethodCheck(this, ref);
        now = new Date();
        minutes = now.getMinutes();
        if (minutes < 10) {
          minutes = "0" + minutes;
        }
        time = now.getHours() + ":" + minutes;
        date = now.getMonth() + "-" + now.getDate() + "-" + now.getFullYear();
        return time + " on " + date;
      }

      setParsedPath() {
        var i, isParamPart, len, paramNames, part, path, pathParts, regexParts;
        boundMethodCheck(this, ref);
        isParamPart = (part) => {
          return part.length > 2 && part.charAt(0) === "<" && part.charAt(part.length - 1) === ">";
        };
        path = this.get("routePath");
        pathParts = path.split("/");
        paramNames = [];
        regexParts = [];
        if (pathParts.length === 0) {
          return paramNames;
        }
        pathParts[pathParts.length - 1] = this.sanitizePathPart(_.last(pathParts));
        for (i = 0, len = pathParts.length; i < len; i++) {
          part = pathParts[i];
          // If part matches the form "<something>" then it is a parameter.
          if (isParamPart(part)) {
            paramNames.push(part.slice(1, -1)); // Remove start and end brackets
            regexParts.push("([^/]+)"); // Add a matching regex for this parameter
          } else {
            // TODO: Need to encode anything that is URL-safe but not regex-safe
            regexParts.push(part); // Add the part as a raw string to the regex
          }
        }
        this.pathRegex = "^/?" + regexParts.join("/") + "/?$"; // Indifferent to starting or trailing slash
        return this.set("paramNames", paramNames);
      }

      sanitizePathPart(part) {
        boundMethodCheck(this, ref);
        part = part.split("#")[0];
        part = part.split("&")[0];
        return part;
      }

      validate(attrs) {
        var invalid;
        boundMethodCheck(this, ref);
        invalid = {};
        if (_.has(attrs, "name") && !/^[$A-Z_][0-9A-Z_$]*$/i.test(attrs.name)) {
          invalid.name = true;
        }
        // Route path matches multiple groups of
        // "letters,digits,_,-" or "<letters,digits,_,->"
        // that begin with a "/"
        if (_.has(attrs, "routePath") && !/^(\/([A-Z\d_-]+|<[A-Z\d_-]+>))+$/i.test(attrs.routePath)) {
          invalid.routePath = true;
        }
        if (!_.isEmpty(invalid)) {
          return invalid;
        }
      }

    };

    Route.prototype.defaults = {
      errorMessage: "", // An error message in the user's function.
      name: "",
      routePath: "",
      routeCode: "", // The function body to execute for this route
      paramNames: [], // This should NOT be set on initialization -- is derived from routePath
      options: {},
      isProductionVersion: false,
      hasBeenEdited: false
    };

    Route.prototype.relations = [
      {
        type: Backbone.HasOne, // nature of the relationship
        key: "productionVersion", // attribute of Route
        relatedModel: "Route" // AssociatedModel for attribute key
      }
    ];

    return Route;

  }).call(this);

}).call(this);
